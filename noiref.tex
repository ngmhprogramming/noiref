\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, left=1in, right=1in, top=1in, bottom=1in]{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}
\usepackage{hyperref}
\usepackage{accsupp}

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    urlcolor=black,
    linktoc=all
}

\lstset{
    frame=tb,
    tabsize=4,
    showstringspaces=false,
    numbers=none,
    commentstyle=\color{purple},
    keywordstyle=\color{orange},
    numberstyle=\color{gray},
    stringstyle=\color{green},
    basicstyle=\ttfamily
}

\title{Competitive Programming Reference}
\author{ngmh}
\date{Last Updated: 07/01/2026}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Data Structures}
\begin{table}[H]
\begin{tabular}{|c|c|c|c|c|c|}
\hline
Data Structure & Precomputation & Update   & Query    & Memory     & Notes                                \\ \hline
Prefix Sum     & O(N)           & X        & O(1)     & O(N)       & Associative Functions (+, XOR)       \\ \hline
Sparse Table   & O(N log N)     & X        & O(1)     & O(N log N) & Non-Associative Functions (max, gcd) \\ \hline
Fenwick Tree   & X              & O(log N) & O(log N) & O(N)       & Prefix Operations                    \\ \hline
Segment Tree   & X              & O(log N) & O(log N) & O(4N)      & Very flexible and extendable         \\ \hline
\end{tabular}
\end{table}

\subsection{Prefix Sums}
\subsubsection{1D}
$O(N)$ precomputation, $O(1)$ query.
\lstinputlisting[language=C++]{src/ds_ps_1d.cpp}

\subsubsection{2D}
$O(R\cdot C)$ precomputation, $O(1)$ query.
\lstinputlisting[language=C++]{src/ds_ps_2d.cpp}

\subsection{Fenwick Trees}
\subsubsection{Point Update Range Query}
$O(\log N)$ update and query.
\lstinputlisting[language=C++]{src/ds_fw_purq.cpp}

\subsubsection{Range Update Point Query}
$O(\log N)$ update and query.
\lstinputlisting[language=C++]{src/ds_fw_rupq.cpp}

\subsubsection{Range Update Range Query}
$O(\log N)$ update and query.
\lstinputlisting[language=C++]{src/ds_fw_rurq.cpp}

\subsubsection{2D PURQ / RUPQ}
$O(\log N \cdot \log M)$ update and query.
\lstinputlisting[language=C++]{src/ds_fw_2d.cpp}

\subsubsection{2D RURQ}
$O(\log N \cdot \log M)$ update and query.
\lstinputlisting[language=C++]{src/ds_fw_2drurq.cpp}

\subsection{Segment Trees}
\subsubsection{Standard}
$O(\log N)$ point update and range query.
\lstinputlisting[language=C++]{src/ds_st_standard.cpp}

\subsubsection{Lazy Propagation}
$O(\log N)$ range update and range query.
\lstinputlisting[language=C++]{src/ds_st_lazyprop.cpp}

\subsubsection{Lazy Node Creation}
\lstinputlisting[language=C++]{src/ds_st_lazynode.cpp}

\subsubsection{Maxsum}
$O(\log N)$ point update and range query.
\lstinputlisting[language=C++]{src/ds_st_maxsum.cpp}

\subsubsection{Merge Sort Tree / Order Statistics}
Insertion: $O(\log N)$, Building: $O(N \log^2 N)$, Counting: $O(\log^2 N)$, Finding: $O(\log V \cdot \log^2 N)$, Range Max: $O(\log N)$.
\lstinputlisting[language=C++]{src/ds_st_mergesort.cpp}

\subsubsection{2D}
$O(N \cdot \log N \cdot \log M)$ point update and range query.
\lstinputlisting[language=C++]{src/ds_st_2d.cpp}

\section{Graph Theory}
\begin{table}[H]
\begin{tabular}{|c|c|c|}
\hline
Graph Algorithm           & Complexity                                  & Notes                                \\ \hline
DFS                       & O(V+E)                                      & Flood Fill, Trees                    \\ \hline
BFS                       & O(V+E)                                      & Unweighted Shortest Path             \\ \hline
0-1 BFS                   & O(V+E)                                      & Unweighted Shortest Path             \\ \hline
Floyd-Warshall            & O($N^{3}$)                                  & All Pairs Shortest Path              \\ \hline
Bellman-Ford              & O(VE)                                       & Negative Single Source Shortest Path \\ \hline
Dijkstra'                 & O(E log V)                                  & Single Source Shortest Path          \\ \hline
SPFA                      & O(VE)                                       & Negative Single Source Shortest Path \\ \hline
Prim's                    & O(E log V)                                  & Dijkstra's                           \\ \hline
UFDS                      & O($\alpha(n)$)                              & Connectedness                        \\ \hline
Kruskal's                 & O(E log E)                                  & Greedy                               \\ \hline
Toposort                  & O(V+E)                                      & Postorder                            \\ \hline
Floyd's Cycle Finding     & O(V+E)                                      & Outdegree 1                          \\ \hline
Kuhn's                    & O($V^{3}$)                                  & Bipartite Matching                   \\ \hline
Hopcroft-Karp             & O($E\sqrt{V}$)                              & Bipartite Matching                   \\ \hline
Articulation Points       & O(V+E)                                      & Find Splitting Nodes                 \\ \hline
Bridges                   & O(V+E)                                      & Find Splitting Edges                 \\ \hline
SCC                       & O(V+E)                                      & Compress Cycles                      \\ \hline
TSP                       & O($N^22^{N}$)                               & Tour All Nodes                       \\ \hline
Pre/Postorder             & O(V)                                        & Ordering of Nodes                    \\ \hline
Subtree To Range          & O(V)                                        & Ordering Nodes                       \\ \hline
Weighted MIS              & O(V)                                        & Tree DP                              \\ \hline
Diameter                  & O(V)                                        & DFS                                  \\ \hline
$2^K$ Decomposition       & O($N\log N$) precompute, O($\log N$) query  & Find Parent                          \\ \hline
Lowest Common Ancestor    & O($\log N$) query                           & Find Common Parent                   \\ \hline
Heavy Light Decomposition & O(N) precompute, O($\log N$) query          & Decomposition                        \\ \hline
Centroid Decomposition    & O($N \log N$) precompute, $O(\log N)$ query & Decomposition                        \\ \hline
\end{tabular}
\end{table}

\subsection{Depth First Search}
Runs in $O(V + E)$.
\lstinputlisting[language=C++]{src/graph_dfs.cpp}

\subsection{Breadth First Search}
Runs in $O(V + E)$.
\lstinputlisting[language=C++]{src/graph_bfs.cpp}

\subsection{0-1 BFS}
Runs in $O(V + E)$.
\lstinputlisting[language=C++]{src/graph_01bfs.cpp}

\subsection{Floyd-Warshall}
Runs in $O(N^3)$.
\lstinputlisting[language=C++]{src/graph_floydwarshall.cpp}

\subsection{Bellman-Ford}
Runs in $O(VE)$.
\lstinputlisting[language=C++]{src/graph_bellmanford.cpp}

\subsection{Dijkstra's Algorithm}
Runs in $O(E \log V)$.
\lstinputlisting[language=C++]{src/graph_dijkstra.cpp}

\subsection{Shortest Path Faster Algorithm}
Runs in $O(VE)$.
\lstinputlisting[language=C++]{src/graph_spfa.cpp}

\subsection{Prim's Algorithm}
Runs in $O(E \log V)$.
\lstinputlisting[language=C++]{src/graph_prim.cpp}

\subsection{Union Find Disjoint Subset}
With both path compression and union by rank, runs in $O(\alpha(n))$ (basically constant time).
\lstinputlisting[language=C++]{src/graph_ufds.cpp}

\subsection{Kruskal's Algorithm}
Runs in $O(E \log E)$.
\lstinputlisting[language=C++]{src/graph_kruskal.cpp}

\subsection{Topological Sort}
Runs in $O(V + E)$.
\lstinputlisting[language=C++]{src/graph_toposort.cpp}

\subsection{Floyd's Cycle Finding Algorithm}
For graphs with outdegree 1, runs in $O(V + E)$.
\lstinputlisting[language=C++]{src/graph_cycle.cpp}

\subsection{Maximum Cardinality Bipartite Matching}
\subsubsection{Kuhn's Algorithm}
Runs in $O(V^3)$.
\lstinputlisting[language=C++]{src/graph_mcbm_kuhn.cpp}

\subsubsection{Hopcroft-Karp}
Runs in $O(E \cdot \sqrt{V})$.
\lstinputlisting[language=C++]{src/graph_mcbm_hopcroftkarp.cpp}

\subsection{Articulation Points and Bridges}
Using Tarjan's Algorithm, runs in $O(V + E)$.
\lstinputlisting[language=C++]{src/graph_atpbridges.cpp}

\subsection{Strongly Connected Components}
Using Tarjan's Algorithm, runs in $O(V + E)$.
\lstinputlisting[language=C++]{src/graph_scc.cpp}

\subsection{Travelling Salesman Problem}
Both of these solutions run in $O(N^2 \cdot 2^N)$ time.
\subsubsection{Bottom Up}
\lstinputlisting[language=C++]{src/graph_tsp_bu.cpp}

\subsubsection{Top Down}
\lstinputlisting[language=C++]{src/graph_tsp_td.cpp}

\subsection{Trees}

\subsubsection{Pre/Postorder Traversal}
Runs in $O(V)$.
\lstinputlisting[language=C++]{src/graph_tree_order.cpp}

\subsubsection{Subtree to Range}
Runs in $O(V)$.
\lstinputlisting[language=C++]{src/graph_tree_range.cpp}

\subsubsection{Weighted Maximum Independent Set}
Runs in $O(V)$.
\lstinputlisting[language=C++]{src/graph_tree_weightedmis.cpp}

\subsubsection{Diameter}
Runs in $O(V)$.
\lstinputlisting[language=C++]{src/graph_tree_diam.cpp}

\subsubsection{$2^K$ Decomposition}
$O(N \log N)$ precomputation and memory, $O(\log N)$ query.
\lstinputlisting[language=C++]{src/graph_tree_2kdecomp.cpp}

\subsubsection{Lowest Common Ancestor}
Runs in $O(\log N)$.
\lstinputlisting[language=C++]{src/graph_tree_lca.cpp}

\subsubsection{Shortest Path}
Runs in $O(\log N)$.
\lstinputlisting[language=C++]{src/graph_tree_sp.cpp}

\subsubsection{Heavy Light Decomposition}
$O(N)$ precomputation, $O(\log N)$ query (excluding $O(\log N)$ from data structure).
\lstinputlisting[language=C++]{src/graph_tree_hld.cpp}

\subsubsection{Centroid Decomposition}
$O(N \log N)$ precomputation, $O(\log N)$ updates and queries.
\lstinputlisting[language=C++]{src/graph_tree_cd.cpp}

\section{Dynamic Programming}
\begin{table}[H]
\begin{tabular}{|c|c|c|}
\hline
DP Algorithm             & Complexity                      & Notes         \\ \hline
Maxsum                   & O(N)                            &               \\ \hline
LIS - Naive              & O($N^2$)                        &               \\ \hline
LIS - DS / Fast DP       & O($N \log N$)                    &               \\ \hline
Coin Combinations        & O(NV)                           &               \\ \hline
Coin Change              & O(NV)                           &               \\ \hline
Knapsack - 0-1           & O(NS)                           &               \\ \hline
Knapsack - 0-1 No Values & O(NX/64)                        &               \\ \hline
Knapsack - 0-K           & O($\log K+NS$)                   &               \\ \hline
Digit DP                 & O(D)                            &               \\ \hline
Convex Hull Trick        & O(1) insertion and query        & Amortized     \\ \hline
Li Chao Tree             & O($\log X$) insertion and query &               \\ \hline
Divide and Conquer       & O($N \log N$)                    & From O($N^2$) \\ \hline
LCS                      & O($N^2$)                        &               \\ \hline
LCS - LIS                & O($N \log N$)                      &               \\ \hline
\end{tabular}
\end{table}

\subsection{Maxsum}
\subsubsection{1D}
Kadane's Algorithm. Runs in $O(N)$.
\lstinputlisting[language=C++]{src/dp_maxsum_1d.cpp}

\subsection{Longest Increasing Subsequence}
\subsubsection{$N^2$ DP}
\lstinputlisting[language=C++]{src/dp_lis_n2.cpp}

\subsubsection{Data Structure Speedup}
\lstinputlisting[language=C++]{src/dp_lis_ds.cpp}

\subsubsection{$N \log N$ DP}
\lstinputlisting[language=C++]{src/dp_lis_optimal.cpp}

\subsection{Coin Combinations}
Runs in $O(N \cdot V)$.
\lstinputlisting[language=C++]{src/dp_coincombinations.cpp}

\subsection{Coin Change}
Runs in $O(N \cdot V)$.
\lstinputlisting[language=C++]{src/dp_coinchange.cpp}

\subsection{Knapsack}
\subsubsection{0-1}
Runs in $O(N \cdot S)$.
\lstinputlisting[language=C++]{src/dp_knapsack_01.cpp}

\subsubsection{0-1 No Values}
Runs in $O(N\cdot X / 64)$.
\lstinputlisting[language=C++]{src/dp_knapsack_bitset.cpp}

\subsection{Digit DP}
Runs in $O(D)$.
\lstinputlisting[language=C++]{src/dp_digit.cpp}

\subsection{Convex Hull Trick}
Supports insertion and queries in amortised $O(1)$.
\lstinputlisting[language=C++]{src/dp_cht.cpp}

\subsection{Li Chao Tree}
Supports insertion and queries in $O(\log X)$ time where $X$ is the domain.
\lstinputlisting[language=C++]{src/dp_lct.cpp}

\subsection{Divide and Conquer}
Reduces complexity from $O(N^2 \cdot K)$ to $O(N \log N \cdot K)$.
\lstinputlisting[language=C++]{src/dp_dnc.cpp}

\section{Math}
\subsection{Fast Exponentiation}
Runs in $O(\log{b})$.
\lstinputlisting[language=C++]{src/math_powmod.cpp}

\subsection{Prime Factorisation}
Runs in $O(\sqrt{x})$.
\lstinputlisting[language=C++]{src/math_primefac.cpp}

\subsection{Sieve of Eratosthenes}
Runs in $O(n \log \log n)$ with high constant.
\lstinputlisting[language=C++]{src/math_sieve.cpp}

\subsection{Greatest Common Divisor}
Runs in $O(\log \min(a, b))$.
\lstinputlisting[language=C++]{src/math_gcd.cpp}

\subsection{Lowest Common Multiple}
\lstinputlisting[language=C++]{src/math_lcm.cpp}

\subsection{Modular Inverse}
For prime modulo.
\lstinputlisting[language=C++]{src/math_modinv.cpp}

\subsection{$n \choose k$}
Precomputation takes $O(MAXN)$ time, queries answered in $O(1)$.
\lstinputlisting[language=C++]{src/math_nck.cpp}

\subsection{Fibonacci}
Runs in $O(\log N)$ time.
\lstinputlisting[language=C++]{src/math_fibo.cpp}

\section{Algorithms}

\subsection{Binary Search}
Find the cuberoot of $n$. Runs in $O(\log{N})$.
\lstinputlisting[language=C++]{src/algo_bs.cpp}

\subsection{Binary Search using Lifting}
Find the cuberoot of $n$. Runs in $O(\log{N})$.
\lstinputlisting[language=C++]{src/algo_bs_lifting.cpp}

\subsection{Sliding Set}
Speeds up DP from $O(N^2)$ to $O(N \log{N})$.
\lstinputlisting[language=C++]{src/algo_slidingset.cpp}

\subsection{Sliding Window}
Runs in $O(N)$.
\lstinputlisting[language=C++]{src/algo_sw.cpp}

\subsection{Set Merging}
Reduces complexity from $O(Q \cdot N \log N)$ to $O(N \log^2 N)$.
\lstinputlisting[language=C++]{src/algo_setmerging.cpp}

\subsection{Discretisation}
Runs in $O(N \log N)$.
\lstinputlisting[language=C++]{src/algo_discretise.cpp}

\subsection{Meet in the Middle}
Reduces time complexity from $O(2^N)$ to $O(N \cdot 2^{N/2})$.
\lstinputlisting[language=C++]{src/algo_mitm.cpp}

\subsection{On the Fly}
Reduces memory usage from $O(N \cdot K)$ to $O(N)$.
\lstinputlisting[language=C++]{src/algo_otf.cpp}

\subsection{Square Root Decomposition}
$O(N)$ precomputation, $O(1)$ update, $O(\sqrt{n})$ query.
\lstinputlisting[language=C++]{src/algo_sqrtdecomp.cpp}

\subsection{Mo's Algorithm}
Runs in $O((N+Q) \cdot \sqrt{N})$. Does not support online queries or updates.
\lstinputlisting[language=C++]{src/algo_mo.cpp}

\subsection{Strings}
\subsection{Manacher's Algorithm}
Runs in $O(N)$.
\lstinputlisting[language=C++]{src/algo_strings_manacher.cpp}

\subsection{Knuth-Morris-Pratt}
Runs in $O(N)$.
\lstinputlisting[language=C++]{src/algo_strings_kmp.cpp}

\subsection{Z-Function}
Runs in $O(N)$.
\lstinputlisting[language=C++]{src/algo_strings_zfunction.cpp}

\subsection{Suffix Array}
Runs in $O(N \log N)$.
\lstinputlisting[language=C++]{src/algo_strings_suffix.cpp}

\section{Miscellaneous}

\subsection{Maximum Time complexity v/s N}
\begin{table}[H]
\begin{tabular}{|c|c|}
\hline
Complexity     & Maximum in 1s \\ \hline
O(1)           & Infinite      \\ \hline
O(log N)       & $2^{10^{6}}$  \\ \hline
O(sqrt N)      & $10^{14}$     \\ \hline
O(N)           & $10^{7}$      \\ \hline
O(N log N)     & $10^{6}$      \\ \hline
O(N sqrt N)    & $10^{5}$      \\ \hline
O($N^{2}$)     & $10^{4}$      \\ \hline
O($N^{3}$)     & 500           \\ \hline
O($N^{4}$)     & 100           \\ \hline
O($2^{N}$)     & 22            \\ \hline
O(N x $2^{N}$) & 20            \\ \hline
O(N!)          & 12            \\ \hline
O(N x N!)      & 11            \\ \hline
\end{tabular}
\end{table}

\subsection{Fast I/O}
Cannot use with \verb|scanf, printf|.
\lstinputlisting[language=C++]{src/misc_fast_io.cpp}

\subsection{Superfast I/O}
Only for non-negative integer input.
\lstinputlisting[language=C++]{src/misc_superfast_io.cpp}

\subsection{Header}
Macros, functions, and variables.
\lstinputlisting[language=C++]{src/misc_header.cpp}

\subsection{Compile Commands}
\lstinputlisting[language=C++]{src/misc_compile.cpp}

\subsection{Pruning}
Kill execution after a specific time duration.
\lstinputlisting[language=C++]{src/misc_prune.cpp}

\subsection{STL Data Structures and Functions}
\lstinputlisting[language=C++]{src/misc_stl.cpp}

\end{document}