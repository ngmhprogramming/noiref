\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, left=1in, right=1in, top=1in, bottom=1in]{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}
\usepackage{hyperref}
\usepackage{accsupp}

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    urlcolor=black,
    linktoc=all
}

\lstset{
    frame=tb,
    tabsize=4,
    showstringspaces=false,
    numbers=none,
    commentstyle=\color{purple},
    keywordstyle=\color{orange},
    numberstyle=\color{gray},
    stringstyle=\color{green},
    basicstyle=\ttfamily
}

\title{Competitive Programming Reference}
\author{ngmh}
\date{Last Updated: 07/01/2026}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Data Structures}
\begin{table}[H]
\begin{tabular}{|c|c|c|c|c|}
\hline
Data Structure & Precomputation / Update & Query    & Memory     & Notes                                \\ \hline
Prefix Sum     & O(N) / X                & O(1)     & O(N)       & Associative Functions (+, XOR)       \\ \hline
Sparse Table   & O(N log N) / X          & O(1)     & O(N log N) & Non-Associative Functions (max, gcd) \\ \hline
Fenwick Tree   & X / O(log N)            & O(log N) & O(N)       & Prefix Sum with Updates              \\ \hline
Segment Tree   & X / O(log N)            & O(log N) & O(4N)      & Allows more Information              \\ \hline
\end{tabular}
\caption{Quick Summary of Data Structures}
\label{tab:ds}
\end{table}

\subsection{Prefix Sums}
\subsubsection{1D}
$O(N)$ precomputation, $O(1)$ query.
\lstinputlisting[language=C++]{src/ds_ps_1d.cpp}

\subsubsection{2D}
$O(R\cdot C)$ precomputation, $O(1)$ query.
\lstinputlisting[language=C++]{src/ds_ps_2d.cpp}

\subsection{Fenwick Trees}
\subsubsection{Point Update Range Query}
$O(\log N)$ update and query.
\lstinputlisting[language=C++]{src/ds_fw_purq.cpp}

\subsubsection{Range Update Point Query}
$O(\log N)$ update and query.
\lstinputlisting[language=C++]{src/ds_fw_rupq.cpp}

\subsubsection{Range Update Range Query}
$O(\log N)$ update and query.
\lstinputlisting[language=C++]{src/ds_fw_rurq.cpp}

\subsubsection{2D PURQ / RUPQ}
$O(\log N \cdot \log M)$ update and query.
\lstinputlisting[language=C++]{src/ds_fw_2d.cpp}

\subsubsection{2D RURQ}
$O(\log N \cdot \log M)$ update and query.
\lstinputlisting[language=C++]{src/ds_fw_2drurq.cpp}

\subsection{Segment Trees}
\subsubsection{Standard}
$O(\log N)$ point update and range query.
\lstinputlisting[language=C++]{src/ds_st_standard.cpp}

\subsubsection{Lazy Propagation}
$O(\log N)$ range update and range query.
\lstinputlisting[language=C++]{src/ds_st_lazyprop.cpp}

\subsubsection{Maxsum}
$O(\log N)$ point update and range query.
\lstinputlisting[language=C++]{src/ds_st_maxsum.cpp}

\subsubsection{Merge Sort Tree / Order Statistics}
Insertion: $O(\log N)$, Building: $O(N \log^2 N)$, Counting: $O(\log^2 N)$, Finding: $O(\log V \cdot \log^2 N)$, Range Max: $O(\log N)$.
\lstinputlisting[language=C++]{src/ds_st_mergesort.cpp}

\subsubsection{2D}
$O(N \cdot \log N \cdot \log M)$ point update and range query.
\lstinputlisting[language=C++]{src/ds_st_2d.cpp}

\section{Graph Theory}

\subsection{Depth First Search}
Runs in $O(V + E)$.
\lstinputlisting[language=C++]{src/graph_dfs.cpp}

\subsection{Breadth First Search}
Runs in $O(V + E)$.
\lstinputlisting[language=C++]{src/graph_bfs.cpp}

\subsection{0-1 BFS}
Runs in $O(V + E)$.
\lstinputlisting[language=C++]{src/graph_01bfs.cpp}

\subsection{Floyd-Warshall}
Runs in $O(N^3)$.
\lstinputlisting[language=C++]{src/graph_floydwarshall.cpp}

\subsection{Bellman-Ford}
Runs in $O(VE)$.
\lstinputlisting[language=C++]{src/graph_bellmanford.cpp}

\subsection{Dijkstra's Algorithm}
Runs in $O(E \log V)$.
\lstinputlisting[language=C++]{src/graph_dijkstra.cpp}

\subsection{Shortest Path Faster Algorithm}
Runs in $O(VE)$.
\lstinputlisting[language=C++]{src/graph_spfa.cpp}

\subsection{Prim's Algorithm}
Runs in $O(E \log V)$.
\lstinputlisting[language=C++]{src/graph_prim.cpp}

\subsection{Union Find Disjoint Subset}
With both path compression and union by rank, runs in $O(\alpha(n))$ (basically constant time).
\lstinputlisting[language=C++]{src/graph_ufds.cpp}

\subsection{Kruskal's Algorithm}
Runs in $O(E \log E)$.
\lstinputlisting[language=C++]{src/graph_kruskal.cpp}

\subsection{Topological Sort}
Runs in $O(V + E)$.
\lstinputlisting[language=C++]{src/graph_toposort.cpp}

\subsection{Floyd's Cycle Finding Algorithm}
For graphs with outdegree 1, runs in $O(V + E)$.
\lstinputlisting[language=C++]{src/graph_cycle.cpp}

\subsection{Maximum Cardinality Bipartite Matching}
\subsubsection{Kun's Algorithm}
Runs in $O(V^3)$.
\lstinputlisting[language=C++]{src/graph_mcbm_kuhn.cpp}

\subsubsection{Hopcroft-Karp}
Runs in $O(E \cdot \sqrt{V})$.
\lstinputlisting[language=C++]{src/graph_mcbm_hopcroftkarp.cpp}

\subsection{Articulation Points and Bridges}
Using Tarjan's Algorithm, runs in $O(V + E)$.
\lstinputlisting[language=C++]{src/graph_atpbridges.cpp}

\subsection{Strongly Connected Components}
Using Tarjan's Algorithm, runs in $O(V + E)$.
\lstinputlisting[language=C++]{src/graph_scc.cpp}

\subsection{Travelling Salesman Problem}
Both of these solutions run in $O(N^2 \cdot 2^N)$ time.
\subsubsection{Bottom Up}
\lstinputlisting[language=C++]{src/graph_tsp_bu.cpp}

\subsubsection{Top Down}
\lstinputlisting[language=C++]{src/graph_tsp_td.cpp}

\subsection{Trees}

\subsubsection{Pre/Postorder Traversal}
Runs in $O(V)$.
\lstinputlisting[language=C++]{src/graph_tree_order.cpp}

\subsubsection{Subtree to Range}
Runs in $O(V)$.
\lstinputlisting[language=C++]{src/graph_tree_range.cpp}

\subsubsection{Weighted Maximum Independent Set}
Runs in $O(V)$.
\lstinputlisting[language=C++]{src/graph_tree_weightedmis.cpp}

\subsubsection{Diameter}
Runs in $O(V)$.
\lstinputlisting[language=C++]{src/graph_tree_diam.cpp}

\subsubsection{$2^K$ Decomposition}
$O(N \log N)$ precomputation and memory, $O(\log N)$ query.
\lstinputlisting[language=C++]{src/graph_tree_2kdecomp.cpp}

\subsubsection{Lowest Common Ancestor}
Runs in $O(\log N)$.
\lstinputlisting[language=C++]{src/graph_tree_lca.cpp}

\subsubsection{Shortest Path}
Runs in $O(\log N)$.
\lstinputlisting[language=C++]{src/graph_tree_sp.cpp}

\subsubsection{Heavy Light Decomposition}
$O(N)$ precomputation, $O(\log N)$ query (excluding $O(\log N)$ from data structure).
\lstinputlisting[language=C++]{src/graph_tree_hld.cpp}

\subsubsection{Centroid Decomposition}
$O(N \log N)$ precomputation, $O(\log N)$ updates and queries.
\lstinputlisting[language=C++]{src/graph_tree_cd.cpp}

\section{Dynamic Programming}

\subsection{Maxsum}
\subsubsection{1D}
Kadane's Algorithm. Runs in $O(N)$.
\lstinputlisting[language=C++]{src/dp_maxsum_1d.cpp}

\subsection{Longest Increasing Subsequence}
\subsubsection{$N^2$ DP}
\lstinputlisting[language=C++]{src/dp_lis_n2.cpp}

\subsubsection{Data Structure Speedup}
\lstinputlisting[language=C++]{src/dp_lis_ds.cpp}

\subsubsection{$N \log N$ DP}
\lstinputlisting[language=C++]{src/dp_lis_optimal.cpp}

\subsection{Coin Combinations}
Runs in $O(N \cdot V)$.
\lstinputlisting[language=C++]{src/dp_coincombinations.cpp}

\subsection{Coin Change}
Runs in $O(N \cdot V)$.
\lstinputlisting[language=C++]{src/dp_coinchange.cpp}

\subsection{Knapsack}
\subsubsection{0-1}
Runs in $O(N \cdot S)$.
\lstinputlisting[language=C++]{src/dp_knapsack_01.cpp}

\subsection{Digit DP}
Runs in $O(D)$.
\lstinputlisting[language=C++]{src/dp_digit.cpp}

\subsection{Convex Hull Trick}
Supports insertion and queries in amortised $O(1)$.
\lstinputlisting[language=C++]{src/dp_cht.cpp}

\subsection{Li Chao Tree}
Supports insertion and queries in $O(\log X)$ time where $X$ is the domain.
\lstinputlisting[language=C++]{src/dp_lct.cpp}

\subsection{Divide and Conquer}
Reduces complexity from $O(N^2 \cdot K)$ to $O(N \log N \cdot K)$.
\lstinputlisting[language=C++]{src/dp_dnc.cpp}

\section{Math}
\subsection{Fast Exponentiation}
Runs in $O(\log{b})$.
\lstinputlisting[language=C++]{src/math_powmod.cpp}

\subsection{Prime Factorisation}
Runs in $O(\sqrt{x})$.
\lstinputlisting[language=C++]{src/math_primefac.cpp}

\subsection{Sieve of Eratosthenes}
Runs in $O(n \log \log n)$ with high constant.
\lstinputlisting[language=C++]{src/math_sieve.cpp}

\subsection{Greatest Common Divisor}
Runs in $O(\log \min(a, b))$.
\lstinputlisting[language=C++]{src/math_gcd.cpp}

\subsection{Lowest Common Multiple}
\lstinputlisting[language=C++]{src/math_lcm.cpp}

\subsection{Modular Inverse}
For prime modulo.
\lstinputlisting[language=C++]{src/math_modinv.cpp}

\subsection{$n \choose k$}
Precomputation takes $O(MAXN)$ time, queries answered in $O(1)$.
\lstinputlisting[language=C++]{src/math_nck.cpp}

\subsection{Fibonacci}
Runs in $O(\log N)$ time.
\lstinputlisting[language=C++]{src/math_fibo.cpp}

\section{Algorithms}

\subsection{Binary Search}
Find the cuberoot of $n$. Runs in $O(\log{N})$.
\lstinputlisting[language=C++]{src/algo_bs.cpp}

\subsection{Binary Search using Lifting}
Find the cuberoot of $n$. Runs in $O(\log{N})$.
\lstinputlisting[language=C++]{src/algo_bs_lifting.cpp}

\subsection{Sliding Set}
Speeds up DP from $O(N^2)$ to $O(N \log{N})$.
\lstinputlisting[language=C++]{src/algo_slidingset.cpp}

\subsection{Set Merging}
Reduces complexity from $O(Q \cdot N \log N)$ to $O(N \log^2 N)$.
\lstinputlisting[language=C++]{src/algo_setmerging.cpp}

\subsection{Discretisation}
Runs in $O(N \log N)$.
\lstinputlisting[language=C++]{src/algo_discretise.cpp}

\section{Miscellaneous}

\subsection{Fast I/O}
Cannot use with \verb|scanf, printf|.
\lstinputlisting[language=C++]{src/misc_fast_io.cpp}

\subsection{Superfast I/O}
Only for non-negative integer input.
\lstinputlisting[language=C++]{src/misc_superfast_io.cpp}

\end{document}